"""
Graph engines
These function are graph engins apecifically for useing with
the graph data structure defined by GEOMETRY_TASK_GRAPH
and its following sub-class.
"""
import Queue
# import sys


# Kernel function for finding reachability
def Explore(nid, adj, visited):
    """
    Recursive function for depth-first search.
    """
    visited[nid] = True
    for to_nid, eid in adj[nid]:
        if not visited[to_nid]:
            Explore(to_nid, adj, visited)
    # the end

# Kernel function for finding reachability
def Explore_capacity(nid, adj, nodes, edges, visited, T_zone, priority=0, agent_id=None):
    """
    Recursive function for depth-first search.
    """
    visited[nid] = True
    if not nodes[nid].is_available_for_T_zone(T_zone, priority, agent_id):
        return
    # Else
    for to_nid, eid in adj[nid]:
        if not visited[to_nid] and edges[eid].is_available_for_T_zone(T_zone, priority, agent_id):
                Explore_capacity(to_nid, adj, nodes, edges, visited, T_zone, priority, agent_id)
    # the end

# Kernel function for finding connected components
def Explore_cc(nid, adj, visited, cc, CCnum):
    """
    Recursive function for depth-first search.
    """
    visited[nid] = True
    CCnum[nid] = cc
    for to_nid, eid in adj[nid]:
        if not visited[to_nid]:
            Explore_cc(to_nid, adj, visited, cc, CCnum)
    # the end

# Kernel function for finding connected components
def Explore_cc_capcity(nid, adj, nodes, edges, visited, cc, CCnum, T_zone, priority=0, agent_id=None):
    """
    Recursive function for depth-first search.
    """
    visited[nid] = True
    CCnum[nid] = cc
    if not nodes[nid].is_available_for_T_zone(T_zone, priority, agent_id):
        return
    # Else
    for to_nid, eid in adj[nid]:
        if not visited[to_nid] and edges[eid].is_available_for_T_zone(T_zone, priority, agent_id):
            Explore_cc_capcity(to_nid, adj, nodes, edges, visited, cc, CCnum, T_zone, priority, agent_id)
    # the end







#------------------------------------------------#
def reachability(x, y, adj, nodes=None, edges=None, count_capacity=True, T_zone=(0,None), priority=0, agent_id=None):
    """
    Finding the reachiability from node_id:x to node_id:y

    Important: This method only consider the current
               (a specific time instant) topological state.

    """
    visited = [False for _ in range(len(adj))]
    if count_capacity:
        Explore_capacity(x, adj, nodes, edges, visited, T_zone, priority, agent_id)
    else:
        # Simply traverse through the topology of graph,
        # not counting capacity of edges
        Explore(x, adj, visited)
    return visited[y]

def number_of_connected_components(adj, nodes=None, edges=None, count_capacity=True, T_zone=(0,None), priority=0, agent_id=None):
    """
    Find the total number of connected components

    Important: This method only consider the current
               (a specific time instant) topological state.

    """
    visited = [False for _ in range(len(adj))]
    CCnum =   [0 for _ in range(len(adj))]
    cc = 1
    if count_capacity:
        for nid in range(len(adj)):
            if not visited[nid]:
                Explore_cc_capcity(nid, adj, nodes, edges, visited, cc, CCnum, T_zone, priority, agent_id)
                cc += 1
    else:
        # Simply traverse through the topology of graph,
        # not counting capacity of edges
        for nid in range(len(adj)):
            if not visited[nid]:
                Explore_cc(nid, adj, visited, cc, CCnum)
                cc += 1
    return (cc-1)


# Graph traversal
#--------------------------------#
def get_path(prev, last_nid, is_reversing_path=True):
    """
    This utility function help generate the path from parent list.
    inputs
        - prev
        - last_nid: the node_id to start backtracking with
        - is_reversing_path (default: True): Decide if we are going to return the path generated by following parent list

    outputs
        - path
    """
    nid_i = last_nid;
    path_inv = list()
    path_inv.append(nid_i)
    while True:
        nid_prev = prev[nid_i]
        if not nid_prev is None:
            nid_i = nid_prev
            path_inv.append(nid_prev)
        else:
            # No parent, not able to continue
            break
    #
    if is_reversing_path:
        # Reverse the path, make it from start_id to end_id
        path = path_inv[::-1]
        return path
    else:
        return path_inv



def dijkstras(adj, nodes, edges, T_zone_start, start_id, end_id, priority=0, agent_id=None):
    """
    This method ues dijkstra alogorithm to find out the best path
    or find out that there is no path at all.

    Optimization problem:
        Given a graph, the state of graph, the time-zone at start_id,
        find a path with "valid edges" that minimize the
        "duration_max" at reaching the end_id
        (after passing through the last edge)

    inputs
        - adj: adjacent graph
        - T_zone_start = (T_min, T_max)
        - start_id
        - end_id
        - priority
        - agent_id (default: None): If agent_id is given, ignore this agent in this edge.

    outputs
        - path/None: a sequence (list) of node_id from start_id to end_id
                     or "None" means no valid path
    """

    # We minimize the T_max
    id_opt_target = 1 # minimize the total duration_max
    max_value = float('inf') # sys.maxsize


    # Get sizes
    num_nodes = len(adj)
    num_edges = len(edges)

    # Initialize the dist and prev
    dist = [max_value for _ in range(num_nodes)] # distance list, "None" stand for infinity
    prev = [None for _ in range(num_nodes)] # Parents list, "None" stands for no parent
    T_zone_nodes = [(max_value, max_value) for _ in range(num_nodes)] # (T_min, T_max) of each node / "Key" for passing edges!

    #-------------------------------#

    # dist[s] = 0 <-- acturally, minimum distance in graph, not actually need to be zero
    dist[start_id] = 0 # Count for the duration, minimum or maximum (or maybe the difference??)
    T_zone_nodes[start_id] = T_zone_start

    # Make a min-heap
    heap = Queue.PriorityQueue()
    for u in range(num_nodes):
        heap.put_nowait( (dist[u], u) )

    # Iteration
    while (not heap.empty()):
        # Get a node_id from heap (currently smallest distance)
        #----------------------------------#
        uh = heap.get_nowait()
        # Filter out some trash in heap
        while uh[0] != dist[uh[1]] and (not heap.empty()):
            # Pop out old one and try new one
            uh = heap.get_nowait()
        if heap.empty():
            # This means that the heap actually has no valuable things
            # in this iteration, just leave
            break
        #----------------------------------#

        # for all (u,v) in E
        # We have to find nodes through "valid" edges
        # that is, it is "possible to pass", it is activated (if we want to check)
        nid_u = uh[1]
        # print("uh[0] = " + str(uh[0]) + ", uh[1] = " + str(uh[1]))
        for nid_v, eid in adj[nid_u]:
            # Check if the edge is available
            # nid_u --eid--> nid_v
            if edges[eid].is_possible_to_pass(T_zone_nodes[nid_u], priority, agent_id):
                # Relax
                if id_opt_target == 2:
                    weight_uv = edges[eid].duration[1] - edges[eid].duration[0] # Minimoze the difference of duration_max and duration_min, for minimizing the uncertainties
                else:
                    weight_uv = edges[eid].duration[id_opt_target] # Minimize the total duration with specified id_opt_target
                #
                if dist[nid_v] > (dist[nid_u] + weight_uv):
                    T_zone_node_v = edges[eid].get_T_zone_end_from_start(T_zone_nodes[nid_u]) # Update time_zone of the node
                    # Check if the next node is available
                    if nodes[nid_v].is_available_for_T_zone(T_zone_node_v, priority, agent_id):
                        dist[nid_v] = (dist[nid_u] + weight_uv)
                        T_zone_nodes[nid_v] = T_zone_node_v
                        prev[nid_v] = nid_u
                        """
                        print("update (u, v) = (%d, %d)" % (nid_u, nid_v))
                        print("dist = " + str(dist))
                        print("prev = " + str(prev))
                        print("\n")
                        """
                        heap.put_nowait( (dist[nid_v], nid_v) )
            #
        # end for
    # end while
    """
    # Post proccesing: replace max_value with "None"
    for i in range(len(dist)):
        if dist[i] == max_value:
            dist[i] = None
    """
    # test
    try:
        delta_T_max = dist[end_id] - dist[start_id]
    except:
        delta_T_max = None
    #
    print("\n")
    print("INFO: Dijkstra finished")
    print("INFO: Distance from start_id <%d> to end_id <%d> = %s" % (start_id, end_id, (str(delta_T_max) if not delta_T_max is None else "None" ) ) )
    print("dist = " + str(dist))
    print("prev = " + str(prev))
    print("T_zone_nodes[end_id] = " + str(T_zone_nodes[end_id]))
    #

    # Generate the path
    if (dist[end_id] is None) or (dist[end_id] == max_value):
        # The end_id is not reachable from start_id
        # in the sense of "valid" edge traversal
        print('INFO: The end_id is not reachable from start_id in the sense of "valid" edge traversal.')
        return None

    # If the goal is reachable
    path = get_path(prev, end_id, is_reversing_path=True)
    if path[0] != start_id:
        print("ERROR: path[0] != start_id, something wrong in dijkstra.")
    else:
        # print("INFO: The path generated correctly in dijkstra.")
        pass

    # test
    print("path = " + str(path) )
    print("\n")
    #
    return path
#--------------------------------#

# Reversed traversal
#--------------------------------------#
def generate_reverse_graph(adj):
    """
    This function is for used with the adj_graph defined in GEOMETRY_TASK_GRAPH
    outputs
        - adj_reversed: a reversed version of adj (All directed edges will be reversed.)
    """
    adj_reversed = [[] for _ in range(len(adj))]
    for nid_u in range(len(adj)):
        for nid_v, eid_uv in adj[nid_u]:
             adj_reversed[nid_v].append( (nid_u,eid_uv) )
    #
    return adj_reversed

def dijkstras_backtrack(adj_in, nodes, edges, T_zone_end, start_id, end_id, priority=0, agent_id=None):
    """
    This method ues dijkstra alogorithm to find out the best path
    or find out that there is no path at all.

    Optimization problem:
        Given a graph, the state of graph, the time-zone at end_id,
        find a path with "valid edges" that minimize the
        "duration_max" at reaching the start_id
        (before passing through the first edge)

    inputs
        - adj: original adjacent graph
        - T_zone_end = (T_min, T_max)
        - start_id
        - end_id
        - priority
        - agent_id (default: None): If agent_id is given, ignore this agent in this edge.

    outputs
        - path/None: a sequence (list) of node_id from start_id to end_id
                     or "None" means no valid path
    """
    # Get a reversed graph
    adj = generate_reverse_graph(adj_in)


    # We minimize the T_max
    id_opt_target = 1 # minimize the total duration_max
    max_value = float('inf') # sys.maxsize


    # Get sizes
    num_nodes = len(adj)
    num_edges = len(edges)

    # Initialize the dist and prev
    dist = [max_value for _ in range(num_nodes)] # distance list, "None" stand for infinity
    prev = [None for _ in range(num_nodes)] # Parents list, "None" stands for no parent
    T_zone_nodes = [(max_value, max_value) for _ in range(num_nodes)] # (T_min, T_max) of each node / "Key" for passing edges!

    #-------------------------------#

    # dist[s] = 0 <-- acturally, minimum distance in graph, not actually need to be zero
    dist[end_id] = 0 # Count for the duration, minimum or maximum (or maybe the difference??)
    T_zone_nodes[end_id] = T_zone_end

    # Make a min-heap
    heap = Queue.PriorityQueue()
    for u in range(num_nodes):
        heap.put_nowait( (dist[u], u) )

    # Iteration
    while (not heap.empty()):
        # Get a node_id from heap (currently smallest distance)
        #----------------------------------#
        uh = heap.get_nowait()
        # Filter out some trash in heap
        while uh[0] != dist[uh[1]] and (not heap.empty()):
            # Pop out old one and try new one
            uh = heap.get_nowait()
        if heap.empty():
            # This means that the heap actually has no valuable things
            # in this iteration, just leave
            break
        #----------------------------------#

        # for all (u,v) in E
        # We have to find nodes through "valid" edges
        # that is, it is "possible to pass", it is activated (if we want to check)
        nid_u = uh[1]
        # print("uh[0] = " + str(uh[0]) + ", uh[1] = " + str(uh[1]))
        for nid_v, eid in adj[nid_u]:
            # Check if the edge is "valid"
            # nid_u --eid--> nid_v
            if edges[eid].is_possible_to_pass_backtrack(T_zone_nodes[nid_u], priority, agent_id):
                T_v_tmp = edges[eid].get_T_zone_start_from_end(T_zone_nodes[nid_u]) # Update time_zone of the node
                if T_v_tmp[1] < T_v_tmp[0]:
                    # This edge is closed, unable to be backtracked
                    continue
                # Relax
                if id_opt_target == 2:
                    weight_uv = edges[eid].duration[1] - edges[eid].duration[0] # Minimoze the difference of duration_max and duration_min, for minimizing the uncertainties
                else:
                    weight_uv = edges[eid].duration[id_opt_target] # Minimize the total duration with specified id_opt_target
                #
                if dist[nid_v] > (dist[nid_u] + weight_uv):
                    T_zone_node_v = edges[eid].get_T_zone_end_from_start(T_zone_nodes[nid_u]) # Update time_zone of the node
                    # Check if the next node is available
                    if nodes[nid_v].is_available_for_T_zone(T_zone_node_v, priority, agent_id):
                        dist[nid_v] = (dist[nid_u] + weight_uv)
                        T_zone_nodes[nid_v] = T_v_tmp # Update time_zone of the node
                        prev[nid_v] = nid_u
                        """
                        print("update (u, v) = (%d, %d)" % (nid_u, nid_v))
                        print("dist = " + str(dist))
                        print("prev = " + str(prev))
                        print("\n")
                        """
                        heap.put_nowait( (dist[nid_v], nid_v) )
            #
        # end for
    # end while

    """
    # Post proccesing: replace max_value with "None"
    for i in range(len(dist)):
        if dist[i] == max_value:
            dist[i] = None
    """
    # test
    try:
        delta_T_max = dist[start_id] - dist[end_id]
    except:
        delta_T_max = None
    #
    print("\n")
    print("INFO: Dijkstra (backtrack) finished")
    print("INFO: Distance from start_id <%d> to end_id <%d> = %s" % (start_id, end_id, (str(delta_T_max) if not delta_T_max is None else "None" ) ) )
    print("dist = " + str(dist))
    print("prev = " + str(prev))
    print("T_zone_nodes[start_id] = " + str(T_zone_nodes[start_id]))
    #

    # Generate the path
    if (dist[start_id] is None) or (dist[start_id] == max_value):
        # The end_id is not reachable from start_id
        # in the sense of "valid" edge traversal
        print('INFO: The start_id is not reachable from end_id in the sense of "valid" edge backward traversal.')
        return None

    # If the goal is reachable
    path = get_path(prev, start_id, is_reversing_path=False)
    # No need to reverse the path
    if path[-1] != end_id:
        print("ERROR: path[-1] != end_id, something wrong in dijkstra.")
    else:
        # print("INFO: The path generated correctly in dijkstra.")
        pass

    # test
    print("path = " + str(path) )
    print("\n")
    #
    return path
#--------------------------------------#
